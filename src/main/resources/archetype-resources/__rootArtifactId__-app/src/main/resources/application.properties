spring.application.name=${artifactId}

logging.path=/tmp
logging.file=spring.log
logging.level=INFO
logging.pattern.level=%5p
logging.pattern.dateformat=yyyy-MM-dd HH:mm:ss.SSS
#if($showComment)
#[[
# clr:org.springframework.boot.logging.logback.ColorConverter
# wEx:org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter
#logging.pattern.console=%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(%5p) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n%wEx
#logging.pattern.file=%d{yyyy-MM-dd HH:mm:ss.SSS} %5p ${PID:- } --- [%t] %-40.40logger{39} : %m%n%wEx
#]]#
#end
#[[
logging.pattern.console=%gray(%d{yyyy-MM-dd HH:mm:ss.SSS}) %highlight(%5p) %magenta(${PID:- }) %gray(---) %gray([%15.15t]) %cyan(%-40.40logger{39}) %gray(:) %m%n%ex
logging.pattern.file=%d{yyyy-MM-dd HH:mm:ss.SSS} %5p ${PID:- } --- [%t] %-40.40logger{39} : %m%n%ex
#]]#
logging.file.maxSize=10MB
logging.file.maxHistory=0
logging.registerShutdownHook=false
logging.exceptionConversionWord=%wEx

server.port=80
server.address=
server.contextPath=
server.displayName=${artifactId}
#server.error.*=
server.servletPath=/
#server.contextParameters.{key}=
server.useForwardHeaders=
server.serverHeader=
server.maxHttpHeaderSize=0
server.maxHttpPostSize=0
server.connectionTimeout=
#server.ssl.*=
#server.compression.*=
#server.jspServlet.*=

spring.jmx.enabled=true
spring.jmx.server=mbeanServer
spring.jmx.uniqueNames=false

spring.mvc.contentnegotiation.favorParameter=false
spring.mvc.contentnegotiation.favorPathExtension=false
spring.mvc.dateFormat=
spring.mvc.dispatchTraceRequest=false
spring.mvc.dispatchOptionsRequest=true
spring.mvc.view.prefix=/WEB-INF/jsp
spring.mvc.view.suffix=.jsp
spring.thymeleaf.checkTemplate=true
spring.thymeleaf.cache=true
spring.thymeleaf.encoding=UTF-8
spring.thymeleaf.servlet.contentType=text/html
spring.thymeleaf.prefix=classpath:/templates/
spring.thymeleaf.suffix=.html
spring.thymeleaf.mode=HTML
spring.freemarker.contentType=text/html
spring.freemarker.prefix=
spring.freemarker.suffix=.ftl
spring.freemarker.templateLoaderPath=classpath:/templates/
spring.freemarker.preferFileSystemAccess=true
spring.freemarker.charset=UTF-8
spring.freemarker.settings=

spring.quartz.schedulerName=QuartzScheduler
spring.quartz.autoStartup=true
spring.quartz.startupDelay=0
spring.quartz.overwriteExistingJobs=false
spring.quartz.jdbc.commentPrefix=--,\#
#spring.quartz.jdbc.schema=classpath:org/quartz/impl/jdbcjobstore/tables_@@platform@@.sql
spring.quartz.jdbc.initializeSchema=EMBEDDED
spring.quartz.jobStoreType=memory
spring.quartz.waitForJobsToCompleteOnShutdown=false
spring.quartz.properties=

spring.task.execution.pool.allowCoreThreadTimeout=true
spring.task.execution.pool.coreSize=8
spring.task.execution.pool.keepAlive=60s
spring.task.execution.threadNamePrefix=task

spring.messages.basename=messages
spring.messages.encoding=UTF-8
spring.messages.fallbackToSystemLocale=true
spring.messages.alwaysUseMessageFormat=false
spring.messages.useCodeAsDefaultMessage=false

spring.jpa.showSql=false
spring.jpa.database=DEFAULT
spring.jpa.databasePlatform=
spring.jpa.generateDdl=false
spring.jpa.mappingResources=META-INF/mapping.xml

spring.redis.database=0
spring.redis.url=
spring.redis.host=localhost
spring.redis.port=6379
spring.redis.password=
spring.redis.jedis.pool.maxActive=8
spring.redis.jedis.pool.maxIdle=8
spring.redis.jedis.pool.maxWait=-1ms
spring.redis.jedis.pool.minIdle=0

spring.datasource.driverClassName=
spring.datasource.url=
spring.datasource.username=
spring.datasource.password=
spring.datasource.jndiName=
spring.datasource.initializationMode=EMBEDDED
spring.datasource.platform=all
spring.datasource.schema=classpath*:schema-${spring.datasource.platform}.sql,classpath*:schema.sql
spring.datasource.schemaUsername=
spring.datasource.schemaPassword=
spring.datasource.data=classpath*:data-${spring.datasource.platform}.sql,classpath*:data.sql
spring.datasource.dataUsername=
spring.datasource.dataPassword=
spring.datasource.continueOnError=false
spring.datasource.separator=;
spring.datasource.sqlScriptEncoding=
spring.datasource.type=
spring.datasource.validationQuery=
spring.datasource.minIdle=1
spring.datasource.initialSize=1
spring.datasource.connectionProperties=
spring.datasource.druid.connectProperties=druid.stat.logSlowSql=false;druid.stat.slowSqlMillis=3000;druid.stat.mergeSql=false
spring.datasource.druid.initialSize=0
spring.datasource.druid.maxActive=8
spring.datasource.druid.minIdle=0
#spring.datasource.druid.maxIdle=8
spring.datasource.druid.maxWait=-1
spring.datasource.druid.notFullTimeoutRetryCount=0
spring.datasource.druid.validationQueryTimeout=-1
spring.datasource.druid.testOnBorrow=false
spring.datasource.druid.testOnReturn=false
spring.datasource.druid.testWhileIdle=true
spring.datasource.druid.poolPreparedStatements=false
spring.datasource.druid.sharePreparedStatements=false
spring.datasource.druid.maxPoolPreparedStatementPerConnectionSize=10
spring.datasource.druid.maxWaitThreadCount=-1
spring.datasource.druid.accessToUnderlyingConnectionAllowed=true
spring.datasource.druid.timeBetweenEvictionRunsMillis=60000
spring.datasource.druid.numTestsPerEvictionRun=3
spring.datasource.druid.minEvictableIdleTimeMillis=1800000
spring.datasource.druid.maxEvictableIdleTimeMillis=252000000
spring.datasource.druid.phyTimeoutMillis=-1
spring.datasource.druid.removeAbandonedTimeoutMillis=300000
spring.datasource.druid.maxOpenPreparedStatements=-1
spring.datasource.druid.timeBetweenConnectErrorMillis=30000
spring.datasource.druid.connectionErrorRetryAttempts=30
spring.datasource.druid.breakAfterAcquireFailure=false
spring.datasource.druid.transactionThresholdMillis=0
spring.datasource.druid.dupCloseLogEnable=false
spring.datasource.druid.isOracle=false
spring.datasource.druid.useOracleImplicitCache=true
spring.datasource.druid.useLocalSessionState=true
spring.datasource.druid.asyncCloseConnectionEnable=false
spring.datasource.druid.maxCreateTaskCount=3
spring.datasource.druid.failFast=false
spring.datasource.druid.initVariants=false
spring.datasource.druid.initGlobalVariants=false
spring.datasource.druid.statViewServlet.urlPattern=/druid/*

mybatis.configLocation=classpath:mybatis-config.xml
mybatis.mapperLocations=classpath*:sqlmap/*-mapper.xml

spring.aop.proxyTargetClass=true

spring.webservices.path=/services
spring.webservices.wsdlLocations=

spring.rabbitmq.host=localhost
spring.rabbitmq.port=5672
spring.rabbitmq.username=guest
spring.rabbitmq.password=guest
spring.rabbitmq.ssl.enabled=
spring.rabbitmq.ssl.keyStore=
spring.rabbitmq.ssl.keyStoreType=PKCS12
spring.rabbitmq.ssl.keyStorePassword=
spring.rabbitmq.ssl.trustStore=
spring.rabbitmq.ssl.trustStoreType=JKS
spring.rabbitmq.ssl.trustStorePassword=
spring.rabbitmq.ssl.algorithm=
spring.rabbitmq.ssl.validateServerCertificate=true
spring.rabbitmq.ssl.verifyHostname=true
spring.rabbitmq.virtualHost=/
spring.rabbitmq.addresses=
spring.rabbitmq.requestedHeartbeat=
spring.rabbitmq.publisherReturns=
spring.rabbitmq.publisherConfirmType=
spring.rabbitmq.connectionTimeout=
spring.rabbitmq.cache.channel.size=25
spring.rabbitmq.cache.channel.checkoutTimeout=0
spring.rabbitmq.cache.connection.mode=CHANNEL
spring.rabbitmq.cache.connection.size=1
spring.rabbitmq.listener.type=SIMPLE
spring.rabbitmq.listener.simple.concurrency=
spring.rabbitmq.listener.simple.maxConcurrency=
spring.rabbitmq.listener.simple.batchSize=
spring.rabbitmq.listener.simple.missingQueuesFatal=true
spring.rabbitmq.listener.direct.consumersPerQueue=
spring.rabbitmq.listener.direct.missingQueuesFatal=false
spring.rabbitmq.template.retry.enabled=
spring.rabbitmq.template.retry.maxAttempts=3
spring.rabbitmq.template.retry.initialInterval=1000ms
spring.rabbitmq.template.retry.multiplier=1.0
spring.rabbitmq.template.retry.maxInterval=10000ms
spring.rabbitmq.template.mandatory=
spring.rabbitmq.template.receiveTimeout=0
spring.rabbitmq.template.replyTimeout=5000
spring.rabbitmq.template.exchange=
spring.rabbitmq.template.routingKey=
spring.rabbitmq.template.defaultReceiveQueue=
spring.rabbitmq.parsedAddresses=

spring.kafka.bootstrapServers=localhost:9092
spring.kafka.clientId=
spring.kafka.properties=
#spring.kafka.consumer.ssl.*
spring.kafka.consumer.autoCommitInterval=
spring.kafka.consumer.autoOffsetReset=
spring.kafka.consumer.bootstrapServers=
spring.kafka.consumer.clientId=
spring.kafka.consumer.enableAutoCommit=
spring.kafka.consumer.fetchMaxWait=
spring.kafka.consumer.fetchMinSize=
spring.kafka.consumer.groupId=
spring.kafka.consumer.heartbeatInterval=
spring.kafka.consumer.isolationLevel=read_uncommitted
spring.kafka.consumer.keyDeserializer=org.apache.kafka.common.serialization.StringDeserializer
spring.kafka.consumer.valueDeserializer=org.apache.kafka.common.serialization.StringDeserializer
spring.kafka.consumer.maxPollRecords=
spring.kafka.consumer.properties=
#spring.kafka.producer.ssl.*
spring.kafka.producer.acks=
spring.kafka.producer.batchSize=
spring.kafka.producer.bootstrapServers=
spring.kafka.producer.bufferMemory=
spring.kafka.producer.clientId=
spring.kafka.producer.compressionType=
spring.kafka.producer.keySerializer=org.apache.kafka.common.serialization.StringSerializer
spring.kafka.producer.valueSerializer=org.apache.kafka.common.serialization.StringSerializer
spring.kafka.producer.retries=
spring.kafka.producer.transactionIdPrefix=
spring.kafka.producer.properties=
#spring.kafka.admin.ssl.*
spring.kafka.admin.clientId=
spring.kafka.admin.properties=
spring.kafka.admin.failFast=
#spring.kafka.streams.ssl.*
spring.kafka.streams.applicationId=
spring.kafka.streams.autoStartup=true
spring.kafka.streams.bootstrapServers=
spring.kafka.streams.cacheMaxSizeBuffering=
spring.kafka.streams.clientId=
spring.kafka.streams.replicationFactor=
spring.kafka.streams.stateDir=
spring.kafka.streams.properties=
spring.kafka.listener.type=SINGLE
spring.kafka.listener.ackMode=BATCH
spring.kafka.listener.clientId=
spring.kafka.listener.concurrency=
spring.kafka.listener.pollTimeout=5000
spring.kafka.listener.noPollThreshold=3.0
spring.kafka.listener.ackCount=
spring.kafka.listener.ackTime=
spring.kafka.listener.idleEventInterval=
spring.kafka.listener.monitorInterval=30
spring.kafka.listener.logContainerConfig=
spring.kafka.listener.missingTopicsFatal=true
spring.kafka.ssl.keyPassword=
spring.kafka.ssl.keyStoreLocation=
spring.kafka.ssl.keyStorePassword=
spring.kafka.ssl.keyStoreType=
spring.kafka.ssl.trustStoreLocation=
spring.kafka.ssl.trustStorePassword=
spring.kafka.ssl.trustStoreType=
spring.kafka.ssl.protocol=
spring.kafka.jaas.enabled=
spring.kafka.jaas.loginModule=com.sun.security.auth.module.Krb5LoginModule
spring.kafka.jaas.controlFlag=REQUIRED
spring.kafka.jaas.options=
spring.kafka.template.defaultTopic=

#[[
spring.metrics.export.triggers.{name}.enabled=true
spring.metrics.export.triggers.{name}.delayMillis=5000
spring.metrics.export.triggers.{name}.sendLatest=true
spring.metrics.export.triggers.{name}.includes=
spring.metrics.export.triggers.{name}.excludes=
#]]#
spring.metrics.export.aggregate.prefix=
spring.metrics.export.aggregate.keyPattern=
spring.metrics.export.redis.prefix=spring.metrics
spring.metrics.export.redis.key=keys.spring.metrics
spring.metrics.export.statsd.host=
spring.metrics.export.statsd.port=8125
spring.metrics.export.statsd.prefix=

management.endpoints.jmx.domain=org.springframework.boot
management.endpoints.jmx.exposure.include=*
management.endpoints.jmx.exposure.exclude=
#auditevents,beans,caches,configprops,env,flyway,health,heapdump,httptrace,info,integrationgraph,liquibase,logfile,loggers,mappings,metrics,sessions,shutdown,threaddump
management.endpoints.web.exposure.include=health,info
management.endpoints.web.exposure.exclude=
management.endpoints.web.basePath=/actuator

management.metrics.export.atlas.uri=http://localhost:7101/api/v1/publish
management.metrics.export.atlas.meterTimeToLive=15
management.metrics.export.atlas.lwcEnabled=
management.metrics.export.atlas.configRefreshFrequency=10
management.metrics.export.atlas.configTimeToLive=150
management.metrics.export.atlas.configUri=http://localhost:7101/lwc/api/v1/expressions/local-dev
management.metrics.export.atlas.evalUri=http://localhost:7101/lwc/api/v1/evaluate

#[[
eureka.client.enabled=true
eureka.client.registryFetchIntervalSeconds=30
eureka.client.instanceInfoReplicationIntervalSeconds=30
eureka.client.initialInstanceInfoReplicationIntervalSeconds=40
eureka.client.eurekaServiceUrlPollIntervalSeconds=300
eureka.client.proxyPort=
eureka.client.proxyHost=
eureka.client.proxyUserName=
eureka.client.proxyPassword=
eureka.client.eurekaServerReadTimeoutSeconds=8
eureka.client.eurekaServerConnectTimeoutSeconds=5
eureka.client.backupRegistryImpl=
eureka.client.eurekaServerTotalConnections=200
eureka.client.eurekaServerTotalConnectionsPerHost=50
eureka.client.eurekaServerURLContext=
eureka.client.eurekaServerPort=
eureka.client.eurekaServerDNSName=
eureka.client.region=us-east-1
eureka.client.eurekaConnectionIdleTimeoutSeconds=30
eureka.client.registryRefreshSingleVipAddress=
eureka.client.heartbeatExecutorThreadPoolSize=2
eureka.client.heartbeatExecutorExponentialBackOffBound=10
eureka.client.cacheRefreshExecutorThreadPoolSize=2
eureka.client.cacheRefreshExecutorExponentialBackOffBound=10
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka
eureka.client.gZipContent=true
eureka.client.useDnsForFetchingServiceUrls=false
eureka.client.registerWithEureka=true
eureka.client.preferSameZoneEureka=true
eureka.client.logDeltaDiff=
eureka.client.disableDelta=
eureka.client.fetchRemoteRegionsRegistry=
eureka.client.availabilityZones.us-east-1=defaultZone
#eureka.client.availabilityZones.{region}=defaultZone
eureka.client.filterOnlyUpInstances=true
eureka.client.fetchRegistry=true
eureka.client.dollarReplacement=_-
eureka.client.escapeCharReplacement=__
eureka.client.allowRedirects=false
eureka.client.onDemandUpdateStatusChange=true
eureka.client.encoderName=
eureka.client.decoderName=
eureka.client.clientDataAccept=full
eureka.client.shouldUnregisterOnShutdown=true
eureka.client.shouldEnforceRegistrationAtInit=false
#eureka.client.experimental.{name}=

eureka.instance.appname=${spring.application.name:unknown}
eureka.instance.appGroupName=
eureka.instance.instanceEnabledOnit=
eureka.instance.securePort=443
eureka.instance.nonSecurePortEnabled=true
eureka.instance.securePortEnabled=
eureka.instance.leaseRenewalIntervalInSeconds=30
eureka.instance.leaseExpirationDurationInSeconds=90
eureka.instance.virtualHostName=${spring.application.name:unknown}
eureka.instance.secureVirtualHostName=${spring.application.name:unknown}
eureka.instance.aSGName=
eureka.instance.dataCenterInfo=MyOwn
eureka.instance.ipAddress=
eureka.instance.namespace=eureka
eureka.instance.preferIpAddress=false
eureka.instance.hostname=
eureka.instance.nonSecurePort=${server.port:80}
eureka.instance.instanceId=${vcap.application.instanceId:${spring.cloud.client.hostname}:${spring.application.name}:${server.port}}
eureka.instance.statusPageUrlPath=/info
eureka.instance.statusPageUrl=
eureka.instance.homePageUrlPath=/
eureka.instance.homePageUrl=
eureka.instance.healthCheckUrlPath=/health
eureka.instance.healthCheckUrl=
eureka.instance.secureHealthCheckUrl=
eureka.instance.metadataMap.zone=
# override eureka.instance.instanceId
eureka.instance.metadataMap.instanceId=${vcap.application.instanceId:${spring.cloud.client.hostname}:${spring.application.name}:${spring.application.instanceId:${server.port}}}
eureka.instance.metadataMap.jmx.port=${com.sun.management.jmxremote.port}
eureka.instance.metadataMap.management.port=${management.server.port}

# ribbon configuration, default namespace: ribbon, key refer: com.netflix.client.config.CommonClientConfigKey
#{clientname}.{namespace}.{key}=
#{namespace}.{key}=

netflix.atlas.uri=
netflix.atlas.enabled=true
netflix.atlas.batchSize=10000
#]]#